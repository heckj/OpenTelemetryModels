// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opentelemetry/proto/metrics/v1/metrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A collection of InstrumentationLibraryMetrics from a Resource.
public struct Opentelemetry_Proto_Metrics_V1_ResourceMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource for the metrics in this message.
  /// If this field is not set then no resource info is known.
  public var resource: Opentelemetry_Proto_Resource_V1_Resource {
    get {return _resource ?? Opentelemetry_Proto_Resource_V1_Resource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  /// A list of metrics that originate from a resource.
  public var instrumentationLibraryMetrics: [Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resource: Opentelemetry_Proto_Resource_V1_Resource? = nil
}

/// A collection of Metrics produced by an InstrumentationLibrary.
public struct Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instrumentation library information for the metrics in this message.
  /// If this field is not set then no library info is known.
  public var instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary {
    get {return _instrumentationLibrary ?? Opentelemetry_Proto_Common_V1_InstrumentationLibrary()}
    set {_instrumentationLibrary = newValue}
  }
  /// Returns true if `instrumentationLibrary` has been explicitly set.
  public var hasInstrumentationLibrary: Bool {return self._instrumentationLibrary != nil}
  /// Clears the value of `instrumentationLibrary`. Subsequent reads from it will return its default value.
  public mutating func clearInstrumentationLibrary() {self._instrumentationLibrary = nil}

  /// A list of metrics that originate from an instrumentation library.
  public var metrics: [Opentelemetry_Proto_Metrics_V1_Metric] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instrumentationLibrary: Opentelemetry_Proto_Common_V1_InstrumentationLibrary? = nil
}

/// Defines a Metric which has one or more timeseries.
///
/// The data model and relation between entities is shown in the diagram below.
///
/// - Metric is composed of a MetricDescriptor and a list of data points.
/// - MetricDescriptor contains a list of label keys (shown horizontally).
/// - Data is a list of DataPoints (shown vertically).
/// - DataPoint contains a list of label values and a value.
///
///     Metric
///  +----------+         +------------------------+
///  |descriptor|-------->| MetricDescriptor       |
///  |          |         |+-----+-----+   +-----+ |
///  |          |         ||label|label|...|label| |
///  |      data|--+      ||key1 |key2 |   |keyN | |
///  +----------+  |      |+-----+-----+   +-----+ |
///                |      +------------------------+
///                |
///                |      +---------------------------+
///                |      |DataPoint 1                |
///                v      |+------+------+   +------+ |
///             +-----+   ||label |label |...|label | |
///             |  1  |-->||value1|value2|...|valueN| |
///             +-----+   |+------+------+   +------+ |
///             |  .  |   |+-----+                    |
///             |  .  |   ||value|                    |
///             |  .  |   |+-----+                    |
///             |  .  |   +---------------------------+
///             |  .  |                   .
///             |  .  |                   .
///             |  .  |                   .
///             |  .  |   +---------------------------+
///             |  .  |   |DataPoint M                |
///             +-----+   |+------+------+   +------+ |
///             |  M  |-->||label |label |...|label | |
///             +-----+   ||value1|value2|...|valueN| |
///                       |+------+------+   +------+ |
///                       |+-----+                    |
///                       ||value|                    |
///                       |+-----+                    |
///                       +---------------------------+
///
///-----------------------------------------------------------------------
/// DataPoint is a value of specific type corresponding to a given moment in
/// time. Each DataPoint is timestamped.
///
/// DataPoint is strongly typed: each DataPoint type has a specific Protobuf message
/// depending on the value type of the metric and thus there are currently 4 DataPoint
/// messages, which correspond to the types of metric values.
public struct Opentelemetry_Proto_Metrics_V1_Metric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// metric_descriptor describes the Metric.
  public var metricDescriptor: Opentelemetry_Proto_Metrics_V1_MetricDescriptor {
    get {return _metricDescriptor ?? Opentelemetry_Proto_Metrics_V1_MetricDescriptor()}
    set {_metricDescriptor = newValue}
  }
  /// Returns true if `metricDescriptor` has been explicitly set.
  public var hasMetricDescriptor: Bool {return self._metricDescriptor != nil}
  /// Clears the value of `metricDescriptor`. Subsequent reads from it will return its default value.
  public mutating func clearMetricDescriptor() {self._metricDescriptor = nil}

  /// Data is a list of one or more DataPoints for a single metric. Only one of the
  /// following fields is used for the data, depending on the type of the metric defined
  /// by MetricDescriptor.type field.
  public var int64DataPoints: [Opentelemetry_Proto_Metrics_V1_Int64DataPoint] = []

  public var doubleDataPoints: [Opentelemetry_Proto_Metrics_V1_DoubleDataPoint] = []

  public var histogramDataPoints: [Opentelemetry_Proto_Metrics_V1_HistogramDataPoint] = []

  public var summaryDataPoints: [Opentelemetry_Proto_Metrics_V1_SummaryDataPoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricDescriptor: Opentelemetry_Proto_Metrics_V1_MetricDescriptor? = nil
}

/// Defines a metric type and its schema.
public struct Opentelemetry_Proto_Metrics_V1_MetricDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name of the metric, including its DNS name prefix. It must be unique.
  public var name: String = String()

  /// description of the metric, which can be used in documentation.
  public var description_p: String = String()

  /// unit in which the metric value is reported. Follows the format
  /// described by http://unitsofmeasure.org/ucum.html.
  public var unit: String = String()

  public var type: Opentelemetry_Proto_Metrics_V1_MetricDescriptor.TypeEnum = .unspecified

  /// The set of labels associated with the metric descriptor. Labels in this list apply to
  /// all data points.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of the metric. It describes how the data is reported.
  ///
  /// A gauge is an instantaneous measurement of a value.
  ///
  /// A counter/cumulative measurement is a value accumulated over a time
  /// interval. In a time series, cumulative measurements should have the same
  /// start time, increasing values, until an event resets the cumulative value
  /// to zero and sets a new start time for the subsequent points.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Do not use this default value.
    case unspecified // = 0

    /// Integer gauge. The value can go both up and down over time.
    /// Corresponding values are stored in Int64DataPoint.
    case gaugeInt64 // = 1

    /// Floating point gauge. The value can go both up and down over time.
    /// Corresponding values are stored in DoubleDataPoint.
    case gaugeDouble // = 2

    /// Histogram gauge measurement.
    /// Used in scenarios like a snapshot of time that current items in a queue
    /// have spent there.
    /// Corresponding values are stored in HistogramDataPoint. The count and sum of the
    /// histogram can go both up and down over time. Recorded values are always >= 0.
    case gaugeHistogram // = 3

    /// Integer counter measurement. The value cannot decrease; if value is reset then
    /// start_time_unix_nano should also be reset.
    /// Corresponding values are stored in Int64DataPoint.
    case counterInt64 // = 4

    /// Floating point counter measurement. The value cannot decrease, if
    /// resets then the start_time_unix_nano should also be reset.
    /// Recorded values are always >= 0.
    /// Corresponding values are stored in DoubleDataPoint.
    case counterDouble // = 5

    /// Histogram cumulative measurement.
    /// Corresponding values are stored in HistogramDataPoint. The count and sum of the
    /// histogram cannot decrease; if values are reset then start_time_unix_nano
    /// should also be reset to the new start timestamp.
    case cumulativeHistogram // = 6

    /// Summary value. Some frameworks implemented Histograms as a summary of observations
    /// (usually things like request durations and response sizes). While it
    /// also provides a total count of observations and a sum of all observed
    /// values, it calculates configurable percentiles over a sliding time
    /// window.
    /// Corresponding values are stored in SummaryDataPoint.
    case summary // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .gaugeInt64
      case 2: self = .gaugeDouble
      case 3: self = .gaugeHistogram
      case 4: self = .counterInt64
      case 5: self = .counterDouble
      case 6: self = .cumulativeHistogram
      case 7: self = .summary
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .gaugeInt64: return 1
      case .gaugeDouble: return 2
      case .gaugeHistogram: return 3
      case .counterInt64: return 4
      case .counterDouble: return 5
      case .cumulativeHistogram: return 6
      case .summary: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Opentelemetry_Proto_Metrics_V1_MetricDescriptor.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opentelemetry_Proto_Metrics_V1_MetricDescriptor.TypeEnum] = [
    .unspecified,
    .gaugeInt64,
    .gaugeDouble,
    .gaugeHistogram,
    .counterInt64,
    .counterDouble,
    .cumulativeHistogram,
    .summary,
  ]
}

#endif  // swift(>=4.2)

/// Int64DataPoint is a single data point in a timeseries that describes the time-varying
/// values of a int64 metric.
public struct Opentelemetry_Proto_Metrics_V1_Int64DataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the time when the cumulative value was reset to zero.
  /// This is used for Counter type only. For Gauge the value is not specified and
  /// defaults to 0.
  ///
  /// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
  /// may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this value was recorded.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  public var timeUnixNano: UInt64 = 0

  /// value itself.
  public var value: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DoubleDataPoint is a single data point in a timeseries that describes the time-varying
/// value of a double metric.
public struct Opentelemetry_Proto_Metrics_V1_DoubleDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the time when the cumulative value was reset to zero.
  /// This is used for Counter type only. For Gauge the value is not specified and
  /// defaults to 0.
  ///
  /// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
  /// may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this value was recorded.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  public var timeUnixNano: UInt64 = 0

  /// value itself.
  public var value: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// HistogramDataPoint is a single data point in a timeseries that describes the time-varying
/// values of a Histogram. A Histogram contains summary statistics for a population of values,
/// it may optionally contain the distribution of those values across a set of buckets.
public struct Opentelemetry_Proto_Metrics_V1_HistogramDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the time when the cumulative value was reset to zero.
  ///
  /// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
  /// may be decided by the backend.
  /// Note: this field is always unspecified and ignored if MetricDescriptor.type==GAUGE_HISTOGRAM.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this value was recorded.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  public var timeUnixNano: UInt64 = 0

  /// count is the number of values in the population. Must be non-negative. This value
  /// must be equal to the sum of the "count" fields in buckets if a histogram is provided.
  public var count: UInt64 = 0

  /// sum of the values in the population. If count is zero then this field
  /// must be zero. This value must be equal to the sum of the "sum" fields in buckets if
  /// a histogram is provided.
  public var sum: Double = 0

  /// buckets is an optional field contains the values of histogram for each bucket.
  ///
  /// The sum of the values in the buckets "count" field must equal the value in the count field.
  ///
  /// The number of elements in buckets array must be by one greater than the
  /// number of elements in bucket_bounds array.
  ///
  /// Note: if HistogramDataPoint.bucket_options defines bucket bounds then this field
  /// must also be present and number of elements in this field must be equal to the
  /// number of buckets defined by bucket_options.
  public var buckets: [Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket] = []

  /// explicit_bounds specifies buckets with explicitly defined bounds for values.
  /// The bucket boundaries are described by "bounds" field.
  ///
  /// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
  /// at index i are:
  ///
  /// [0, bounds[i]) for i == 0
  /// [bounds[i-1], bounds[i]) for 0 < i < N-1
  /// [bounds[i], +infinity) for i == N-1
  /// The values in bounds array must be strictly increasing and > 0.
  ///
  /// Note: only [a, b) intervals are currently supported for each bucket. If we decides
  /// to also support (a, b] intervals we should add support for these by defining a boolean
  /// value which decides what type of intervals to use.
  public var explicitBounds: [Double] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Bucket contains values for a bucket.
  public struct Bucket {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of values in each bucket of the histogram, as described by
    /// bucket_options.
    public var count: UInt64 = 0

    /// exemplar is an optional representative value of the bucket.
    public var exemplar: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar {
      get {return _exemplar ?? Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar()}
      set {_exemplar = newValue}
    }
    /// Returns true if `exemplar` has been explicitly set.
    public var hasExemplar: Bool {return self._exemplar != nil}
    /// Clears the value of `exemplar`. Subsequent reads from it will return its default value.
    public mutating func clearExemplar() {self._exemplar = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Exemplars are example points that may be used to annotate aggregated
    /// Histogram values. They are metadata that gives information about a
    /// particular value added to a Histogram bucket.
    public struct Exemplar {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Value of the exemplar point. It determines which bucket the exemplar belongs to.
      /// If bucket_options define bounds for this bucket then this value must be within
      /// the defined bounds.
      public var value: Double = 0

      /// time_unix_nano is the moment when this exemplar was recorded.
      /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
      public var timeUnixNano: UInt64 = 0

      /// exemplar_attachments are contextual information about the example value.
      /// Keys in this list must be unique.
      public var attachments: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _exemplar: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar? = nil
  }

  public init() {}
}

/// SummaryDataPoint is a single data point in a timeseries that describes the time-varying
/// values of a Summary metric.
public struct Opentelemetry_Proto_Metrics_V1_SummaryDataPoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The set of labels that uniquely identify this timeseries.
  public var labels: [Opentelemetry_Proto_Common_V1_StringKeyValue] = []

  /// start_time_unix_nano is the time when the cumulative value was reset to zero.
  ///
  /// The cumulative value is over the time interval (start_time_unix_nano, time_unix_nano].
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// Value of 0 indicates that the timestamp is unspecified. In that case the timestamp
  /// may be decided by the backend.
  public var startTimeUnixNano: UInt64 = 0

  /// time_unix_nano is the moment when this value was recorded.
  /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  public var timeUnixNano: UInt64 = 0

  /// The total number of recorded values since start_time. Optional since
  /// some systems don't expose this.
  public var count: UInt64 = 0

  /// The total sum of recorded values since start_time. Optional since some
  /// systems don't expose this. If count is zero then this field must be zero.
  public var sum: Double = 0

  /// A list of values at different percentiles of the distribution calculated
  /// from the current snapshot. The percentiles must be strictly increasing.
  public var percentileValues: [Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtPercentile] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents the value at a given percentile of a distribution.
  ///
  /// To record Min and Max values following conventions are used:
  /// - The 100th percentile is equivalent to the maximum value observed.
  /// - The 0th percentile is equivalent to the minimum value observed.
  ///
  /// See the following issue for more context:
  /// https://github.com/open-telemetry/opentelemetry-proto/issues/125
  public struct ValueAtPercentile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The percentile of a distribution. Must be in the interval
    /// [0.0, 100.0].
    public var percentile: Double = 0

    /// The value at the given percentile of a distribution.
    public var value: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opentelemetry.proto.metrics.v1"

extension Opentelemetry_Proto_Metrics_V1_ResourceMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .standard(proto: "instrumentation_library_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._resource)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.instrumentationLibraryMetrics)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.instrumentationLibraryMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instrumentationLibraryMetrics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics, rhs: Opentelemetry_Proto_Metrics_V1_ResourceMetrics) -> Bool {
    if lhs._resource != rhs._resource {return false}
    if lhs.instrumentationLibraryMetrics != rhs.instrumentationLibraryMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstrumentationLibraryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instrumentation_library"),
    2: .same(proto: "metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._instrumentationLibrary)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.metrics)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._instrumentationLibrary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.metrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metrics, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics, rhs: Opentelemetry_Proto_Metrics_V1_InstrumentationLibraryMetrics) -> Bool {
    if lhs._instrumentationLibrary != rhs._instrumentationLibrary {return false}
    if lhs.metrics != rhs.metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_descriptor"),
    2: .standard(proto: "int64_data_points"),
    3: .standard(proto: "double_data_points"),
    4: .standard(proto: "histogram_data_points"),
    5: .standard(proto: "summary_data_points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._metricDescriptor)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.int64DataPoints)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.doubleDataPoints)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.histogramDataPoints)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.summaryDataPoints)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._metricDescriptor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.int64DataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.int64DataPoints, fieldNumber: 2)
    }
    if !self.doubleDataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.doubleDataPoints, fieldNumber: 3)
    }
    if !self.histogramDataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.histogramDataPoints, fieldNumber: 4)
    }
    if !self.summaryDataPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.summaryDataPoints, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Metric, rhs: Opentelemetry_Proto_Metrics_V1_Metric) -> Bool {
    if lhs._metricDescriptor != rhs._metricDescriptor {return false}
    if lhs.int64DataPoints != rhs.int64DataPoints {return false}
    if lhs.doubleDataPoints != rhs.doubleDataPoints {return false}
    if lhs.histogramDataPoints != rhs.histogramDataPoints {return false}
    if lhs.summaryDataPoints != rhs.summaryDataPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_MetricDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "unit"),
    4: .same(proto: "type"),
    5: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularStringField(value: &self.unit)
      case 4: try decoder.decodeSingularEnumField(value: &self.type)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.labels)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 3)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_MetricDescriptor, rhs: Opentelemetry_Proto_Metrics_V1_MetricDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.type != rhs.type {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_MetricDescriptor.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "GAUGE_INT64"),
    2: .same(proto: "GAUGE_DOUBLE"),
    3: .same(proto: "GAUGE_HISTOGRAM"),
    4: .same(proto: "COUNTER_INT64"),
    5: .same(proto: "COUNTER_DOUBLE"),
    6: .same(proto: "CUMULATIVE_HISTOGRAM"),
    7: .same(proto: "SUMMARY"),
  ]
}

extension Opentelemetry_Proto_Metrics_V1_Int64DataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Int64DataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularInt64Field(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_Int64DataPoint, rhs: Opentelemetry_Proto_Metrics_V1_Int64DataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_DoubleDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DoubleDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularDoubleField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_DoubleDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_HistogramDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HistogramDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .same(proto: "buckets"),
    7: .standard(proto: "explicit_bounds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.count)
      case 5: try decoder.decodeSingularDoubleField(value: &self.sum)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.buckets)
      case 7: try decoder.decodeRepeatedDoubleField(value: &self.explicitBounds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
    }
    if !self.buckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buckets, fieldNumber: 6)
    }
    if !self.explicitBounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.explicitBounds, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.buckets != rhs.buckets {return false}
    if lhs.explicitBounds != rhs.explicitBounds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.protoMessageName + ".Bucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "exemplar"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.count)
      case 2: try decoder.decodeSingularMessageField(value: &self._exemplar)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 1)
    }
    if let v = self._exemplar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket, rhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs._exemplar != rhs._exemplar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.protoMessageName + ".Exemplar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "time_unix_nano"),
    3: .same(proto: "attachments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.value)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.attachments)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 2)
    }
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar, rhs: Opentelemetry_Proto_Metrics_V1_HistogramDataPoint.Bucket.Exemplar) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_SummaryDataPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummaryDataPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
    2: .standard(proto: "start_time_unix_nano"),
    3: .standard(proto: "time_unix_nano"),
    4: .same(proto: "count"),
    5: .same(proto: "sum"),
    6: .standard(proto: "percentile_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.labels)
      case 2: try decoder.decodeSingularFixed64Field(value: &self.startTimeUnixNano)
      case 3: try decoder.decodeSingularFixed64Field(value: &self.timeUnixNano)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.count)
      case 5: try decoder.decodeSingularDoubleField(value: &self.sum)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.percentileValues)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    if self.startTimeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.startTimeUnixNano, fieldNumber: 2)
    }
    if self.timeUnixNano != 0 {
      try visitor.visitSingularFixed64Field(value: self.timeUnixNano, fieldNumber: 3)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt64Field(value: self.count, fieldNumber: 4)
    }
    if self.sum != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 5)
    }
    if !self.percentileValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.percentileValues, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint, rhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.startTimeUnixNano != rhs.startTimeUnixNano {return false}
    if lhs.timeUnixNano != rhs.timeUnixNano {return false}
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.percentileValues != rhs.percentileValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtPercentile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.protoMessageName + ".ValueAtPercentile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percentile"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.percentile)
      case 2: try decoder.decodeSingularDoubleField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.percentile != 0 {
      try visitor.visitSingularDoubleField(value: self.percentile, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtPercentile, rhs: Opentelemetry_Proto_Metrics_V1_SummaryDataPoint.ValueAtPercentile) -> Bool {
    if lhs.percentile != rhs.percentile {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
